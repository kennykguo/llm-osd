# llm-os codebase summary

this document summarizes the codebase end-to-end (protocol, daemon, client, docs), including what is implemented, how data flows, and what is covered by tests.

## 1) top-level structure

the repository is a rust workspace with these crates:

- `llm-os-common`: shared protocol types + strict json parsing + validation
- `llm-osd`: privileged unix-socket daemon that validates, applies policy, executes actions, and writes audit logs
- `llmsh`: client cli that validates plans locally and sends execute-mode plans to the daemon

the `docs/` folder contains the contract (`actionplan.schema.json`), usage walkthrough (`USAGE.md`), error codes, and implementation planning notes.

## 2) the core contract: actionplan json

### 2.1 request: `ActionPlan`

the daemon accepts a single json document that serde parses into `llm_os_common::ActionPlan`.

high level fields:

- `request_id`: required correlation id
- `session_id`: optional correlation id
- `version`: protocol version string (mvp uses `"0.1"`)
- `mode`: `plan_only` or `execute`
- `actions`: ordered list of actions
- `confirmation`: optional `{ "token": "..." }` used for daemon-side confirmation gating

strictness:

- all request structs use `#[serde(deny_unknown_fields)]`, so any unknown key triggers a parse failure
- actions are tagged enums: `#[serde(tag = "type", rename_all = "snake_case")]`

### 2.2 response: `ActionPlanResult`

the daemon responds with `llm_os_common::ActionPlanResult`:

- `request_id`: echoed back for correlation
- `executed`: boolean
  - `false` means the daemon did not perform side effects (mode was `plan_only`, or request-level errors)
  - `true` means mode was `execute` and the daemon attempted to execute actions
- `results`: one entry per requested action (typed)
- `error`: optional request-level error (parse/validation/mode/size)

important detail: `executed` is a response-level flag, not per-action.

## 3) llm-os-common (protocol + validation)

file: `llm-os-common/src/lib.rs`

### 3.1 parsing

parsing is performed via serde:

- `parse_action_plan(input: &str) -> Result<ActionPlan, serde_json::Error>`

this provides deterministic failures for:

- invalid json
- unknown fields (because of `deny_unknown_fields`)
- enum/tag mismatches (unknown `type` tag, unknown `mode`, etc.)

### 3.2 validation (anti-hallucination caps)

validation is performed by:

- `validate_action_plan(plan: &ActionPlan) -> Result<(), ValidationError>`

this is a pure function that enforces hard bounds such as:

- max action count
- max `exec.argv` length + per-arg byte length
- max env entries + per-key/per-value byte length
- max lengths for `request_id`, `session_id`, `reason`, `path`, `version`, tokens, etc.
- max `read_file.max_bytes`, max `write_file.content` size
- max `exec.timeout_sec` and rejects `exec.as_root=true` (mvp)

the purpose is to ensure model hallucinations cannot force the daemon into large allocations or expensive work, because invalid plans fail early and deterministically.

## 4) llm-osd (daemon)

files:

- `llm-osd/src/server.rs` (socket server + routing)
- `llm-osd/src/policy.rs` (allowlist/denylist + confirmation gating)
- `llm-osd/src/audit.rs` (append-only audit writer + redaction)
- `llm-osd/src/actions/exec.rs` (exec action)
- `llm-osd/src/actions/files.rs` (read_file/write_file)

### 4.1 unix socket server + request framing

the daemon listens on a unix domain socket (filesystem path like `/tmp/llm-osd.sock`).

request handling steps:

1) accept a connection
2) read bytes into a buffer until:
   - eof, or
   - idle read timeout triggers, or
   - request exceeds the hard byte cap (currently 256kiB)
3) parse json into `ActionPlan`
4) validate the plan
5) for each action:
   - if `mode=execute`, call `execute_action(...)`
   - if `mode=plan_only`, call `plan_action(...)`
6) write `ActionPlanResult` back to the client as json
7) append a redacted audit record

why the idle timeout exists:

- without it, a client that writes json but never closes the socket could cause the server to hang waiting for more bytes
- the daemon treats "idle after receiving bytes" as end-of-message and attempts to parse/execute deterministically

### 4.2 policy + confirmation token gating

file: `llm-osd/src/policy.rs`

policy decisions are deterministic:

- denylist: some executables are always refused (`dd`, `mkfs`, `shutdown`, `reboot`, etc.)
- allowlist without confirmation (mvp): `/bin/echo` only
- confirmation required:
  - `rm` always
  - any non-allowlisted program
- filesystem path confirmation required:
  - absolute paths outside `/tmp/`
  - any path containing `..`

confirmation tokens are checked by string equality against the daemon-configured token.

### 4.3 audit log format + redaction

file: `llm-osd/src/audit.rs`

the audit log is jsonl: one json object per line, appended to the file passed on daemon startup.

each record includes:

- `ts_unix_ms`
- `peer`: unix peer credentials (pid/uid/gid) derived from `SO_PEERCRED`
- `request_id`, `session_id`
- `plan`: redacted plan json
- `result`: redacted result json

redaction matters because secrets can appear in many places (env vars, file contents, stdout/stderr). the daemon redacts:

- `confirmation.token`
- `exec.env` values
- `write_file.content`
- `read_file.content_base64`
- `exec` and `observe` stdout/stderr

### 4.4 action implementations

#### exec

file: `llm-osd/src/actions/exec.rs`

`exec` uses `tokio::process::Command` with:

- argv[0] as the program
- argv[1..] as args
- optional cwd/env
- timeout enforced by `tokio::time::timeout`
- stdout/stderr captured and truncated to a fixed cap

#### files: read_file/write_file

file: `llm-osd/src/actions/files.rs`

- `read_file` reads at most `max_bytes + 1` in a loop (streaming), then base64-encodes up to `max_bytes`
  - `truncated=true` means the file had more than `max_bytes`
- `write_file` writes bytes and applies unix mode (octal parsed) via `set_permissions`

#### observe

observe supports both:

- `plan_only`: returns argv only, no stdout/stderr
- `execute`: the daemon maps the observe tool+args into an exec call and returns stdout/stderr like exec

other "prompt-expanded" actions currently have plan_only support but are policy-denied in execute mode:

- `service_control`
- `install_packages`
- `remove_packages`
- `update_system`
- `cgroup_apply`
- `firmware_op`

this is intentional: the schemas exist and are testable in plan_only, but we refuse to execute them until we implement safety checks and policy.

## 5) llmsh (client cli)

files:

- `llmsh/src/main.rs`: clap-based cli with subcommands
- `llmsh/src/lib.rs`: parsing/validation helpers

subcommands:

- `llmsh validate`: parses + validates locally, outputs a deterministic verdict json
- `llmsh ping`: sends a ping action (execute mode)
- `llmsh send`: parses + validates locally, enforces execute mode, sends to daemon over unix socket

important detail:

- the daemon supports `plan_only`, but `llmsh send` refuses non-execute mode (client-side safety/ux choice)

## 6) test coverage (what is tested)

### llm-os-common

unit tests cover:

- unknown field rejection (parse failures)
- validation caps (action count, argv/env sizes, string sizes)
- read/write caps, timeout caps, mode parsing, as_root rejection

### llm-osd

tests cover:

- request-size cap behavior
- idle timeout handling (complete json without close)
- ping/exec/read/write roundtrips
- confirmation gating for non-allowlisted exec and rm
- path-based confirmation requirements for read/write
- audit redaction (write_file content, stdout/stderr redaction)
- audit includes peer credentials

### llmsh

tests cover:

- validate verdict classification (parse_failed vs validation_failed)
- client refuses plan_only in send mode
- override behavior for request_id/session_id

## 7) current intentional gaps

the "llm provider" does not exist yet. there is no local or remote model integration and no constrained decoding yet.

next step is to add an `llm-provider` component that:

- invokes llama.cpp locally (on-demand, not resident)
- uses grammar-constrained decoding for *this repoâ€™s fixed actionplan schema*
- runs post-parse + validate with `llm-os-common`
- emits a plan (likely `plan_only` first) for human approval, then execute on confirmation


